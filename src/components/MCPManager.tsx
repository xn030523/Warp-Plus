import { useState, useEffect } from 'react';
import { invoke } from '@tauri-apps/api/core';
import './MCPManager.css';

interface TransportType {
  type: string;
  command: string;
  args: string[];
  env?: Record<string, string>;
}

interface MCPServer {
  name: string;
  title: string;
  transport_type: TransportType;
  uuid?: string;
  cached_at?: string;
}

interface RuleMemory {
  name: string;
  content: string;
  is_autogenerated: boolean;
}

interface Rule {
  name: string;
  title: string;
  memory: RuleMemory;
  cached_at?: string;
}

function MCPManager() {
  const [activeTab, setActiveTab] = useState<'mcp' | 'rules'>('mcp');
  const [mcpServers, setMcpServers] = useState<MCPServer[]>([]);
  const [rules, setRules] = useState<Rule[]>([]);
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState<{ type: 'success' | 'error', text: string } | null>(null);

  const [showMcpForm, setShowMcpForm] = useState(false);
  const [showRuleForm, setShowRuleForm] = useState(false);
  const [showImportForm, setShowImportForm] = useState(false);
  const [importJson, setImportJson] = useState('');
  const [editingMcp, setEditingMcp] = useState<MCPServer | null>(null);
  const [editingRule, setEditingRule] = useState<Rule | null>(null);
  const [expandedRules, setExpandedRules] = useState<Set<string>>(new Set());

  // MCP è¡¨å•
  const [newMcp, setNewMcp] = useState({
    name: '',
    type: 'stdio',
    command: '',
    args: '',
    env: '',
  });

  // è§„åˆ™è¡¨å•
  const [newRule, setNewRule] = useState({
    name: '',
    content: '',
  });

  // åŠ è½½æ•°æ®
  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      const [mcps, rls] = await Promise.all([
        invoke<MCPServer[]>('get_mcp_services'),
        invoke<Rule[]>('get_rules'),
      ]);
      setMcpServers(mcps);
      setRules(rls);
    } catch (error) {
      setMessage({ type: 'error', text: `åŠ è½½å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // æ·»åŠ  MCP æœåŠ¡å™¨
  const handleAddMcp = async () => {
    if (!newMcp.name || !newMcp.command) {
      setMessage({ type: 'error', text: 'è¯·å¡«å†™åç§°å’Œå‘½ä»¤' });
      return;
    }

    try {
      setLoading(true);
      const mcp: MCPServer = {
        name: newMcp.name,
        title: newMcp.name,
        transport_type: {
          type: newMcp.type,
          command: newMcp.command,
          args: newMcp.args.split(',').map(s => s.trim()).filter(s => s),
          env: newMcp.env ? JSON.parse(newMcp.env) : {},
        },
      };

      await invoke('save_mcp_service', { service: mcp });
      setMessage({ type: 'success', text: 'MCP æœåŠ¡å·²æ·»åŠ ' });
      setNewMcp({ name: '', type: 'stdio', command: '', args: '', env: '' });
      setShowMcpForm(false);
      await loadData();
    } catch (error) {
      setMessage({ type: 'error', text: `æ·»åŠ å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // æ·»åŠ è§„åˆ™
  const handleAddRule = async () => {
    if (!newRule.name || !newRule.content) {
      setMessage({ type: 'error', text: 'è¯·å¡«å†™è§„åˆ™åç§°å’Œå†…å®¹' });
      return;
    }

    try {
      setLoading(true);
      const rule: Rule = {
        name: newRule.name,
        title: newRule.name,
        memory: {
          name: newRule.name,
          content: newRule.content,
          is_autogenerated: false,
        },
      };

      await invoke('save_rule', { rule });
      setMessage({ type: 'success', text: 'è§„åˆ™å·²æ·»åŠ ' });
      setNewRule({ name: '', content: '' });
      setShowRuleForm(false);
      await loadData();
    } catch (error) {
      setMessage({ type: 'error', text: `æ·»åŠ å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // åˆ é™¤ MCP
  const deleteMcp = async (name: string) => {
    if (!confirm(`ç¡®å®šåˆ é™¤ MCP æœåŠ¡ "${name}"ï¼Ÿ`)) return;

    try {
      setLoading(true);
      await invoke('delete_mcp_service', { name });
      setMessage({ type: 'success', text: 'MCP æœåŠ¡å·²åˆ é™¤' });
      await loadData();
    } catch (error) {
      setMessage({ type: 'error', text: `åˆ é™¤å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // å¼€å§‹ç¼–è¾‘ MCP
  const startEditMcp = (mcp: MCPServer) => {
    setEditingMcp(mcp);
    setNewMcp({
      name: mcp.name,
      type: mcp.transport_type.type,
      command: mcp.transport_type.command,
      args: mcp.transport_type.args.join(', '),
      env: mcp.transport_type.env ? JSON.stringify(mcp.transport_type.env, null, 2) : '',
    });
    setShowMcpForm(true);
  };

  // å–æ¶ˆç¼–è¾‘ MCP
  const cancelEditMcp = () => {
    setEditingMcp(null);
    setNewMcp({ name: '', type: 'stdio', command: '', args: '', env: '' });
    setShowMcpForm(false);
  };

  // ä¿å­˜ç¼–è¾‘çš„ MCP
  const saveEditedMcp = async () => {
    if (!editingMcp || !newMcp.name || !newMcp.command) {
      setMessage({ type: 'error', text: 'è¯·å¡«å†™åç§°å’Œå‘½ä»¤' });
      return;
    }

    try {
      setLoading(true);
      const mcp: MCPServer = {
        name: newMcp.name,
        title: newMcp.name,
        transport_type: {
          type: newMcp.type,
          command: newMcp.command,
          args: newMcp.args.split(',').map(s => s.trim()).filter(s => s),
          env: newMcp.env ? JSON.parse(newMcp.env) : {},
        },
        uuid: editingMcp.uuid,
      };

      await invoke('save_mcp_service', { service: mcp });
      setMessage({ type: 'success', text: 'MCP æœåŠ¡å·²æ›´æ–°' });
      cancelEditMcp();
      await loadData();
    } catch (error) {
      setMessage({ type: 'error', text: `æ›´æ–°å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // å¼€å§‹ç¼–è¾‘è§„åˆ™
  const startEditRule = (rule: Rule) => {
    setEditingRule(rule);
    setNewRule({
      name: rule.name,
      content: rule.memory.content,
    });
    setShowRuleForm(true);
  };

  // å–æ¶ˆç¼–è¾‘è§„åˆ™
  const cancelEditRule = () => {
    setEditingRule(null);
    setNewRule({ name: '', content: '' });
    setShowRuleForm(false);
  };

  // ä¿å­˜ç¼–è¾‘çš„è§„åˆ™
  const saveEditedRule = async () => {
    if (!editingRule || !newRule.name || !newRule.content) {
      setMessage({ type: 'error', text: 'è¯·å¡«å†™è§„åˆ™åç§°å’Œå†…å®¹' });
      return;
    }

    try {
      setLoading(true);
      const rule: Rule = {
        name: newRule.name,
        title: newRule.name,
        memory: {
          name: newRule.name,
          content: newRule.content,
          is_autogenerated: editingRule.memory.is_autogenerated,
        },
      };

      await invoke('save_rule', { rule });
      setMessage({ type: 'success', text: 'è§„åˆ™å·²æ›´æ–°' });
      cancelEditRule();
      await loadData();
    } catch (error) {
      setMessage({ type: 'error', text: `æ›´æ–°å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // åˆ‡æ¢è§„åˆ™å±•å¼€/æ”¶èµ·
  const toggleRuleExpand = (name: string) => {
    const newExpanded = new Set(expandedRules);
    if (newExpanded.has(name)) {
      newExpanded.delete(name);
    } else {
      newExpanded.add(name);
    }
    setExpandedRules(newExpanded);
  };

  // åˆ é™¤è§„åˆ™
  const deleteRule = async (name: string) => {
    if (!confirm(`ç¡®å®šåˆ é™¤è§„åˆ™ "${name}"ï¼Ÿ`)) return;

    try {
      setLoading(true);
      await invoke('delete_rule', { name });
      setMessage({ type: 'success', text: 'è§„åˆ™å·²åˆ é™¤' });
      await loadData();
    } catch (error) {
      setMessage({ type: 'error', text: `åˆ é™¤å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // åº”ç”¨å•ä¸ª MCP åˆ°äº‘ç«¯
  const applyMcpToCloud = async (mcp: MCPServer) => {
    try {
      setLoading(true);
      await invoke('upload_mcp_auto', { service: mcp });
      setMessage({ type: 'success', text: `MCP "${mcp.title}" å·²åº”ç”¨åˆ°äº‘ç«¯` });
    } catch (error) {
      setMessage({ type: 'error', text: `åº”ç”¨å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // åº”ç”¨å•ä¸ªè§„åˆ™åˆ°äº‘ç«¯
  const applyRuleToCloud = async (rule: Rule) => {
    try {
      setLoading(true);
      await invoke('upload_rule_auto', { rule });
      setMessage({ type: 'success', text: `è§„åˆ™ "${rule.title}" å·²åº”ç”¨åˆ°äº‘ç«¯` });
    } catch (error) {
      setMessage({ type: 'error', text: `åº”ç”¨å¤±è´¥: ${error}` });
    } finally {
      setLoading(false);
    }
  };

  // æ‰¹é‡åº”ç”¨æ‰€æœ‰ MCP åˆ°äº‘ç«¯
  const applyAllMcpToCloud = async () => {
    if (mcpServers.length === 0) {
      setMessage({ type: 'error', text: 'æ²¡æœ‰ MCP æœåŠ¡å¯ä»¥åº”ç”¨' });
      return;
    }

    if (!confirm(`ç¡®å®šå°†æ‰€æœ‰ ${mcpServers.length} ä¸ª MCP æœåŠ¡åº”ç”¨åˆ°å½“å‰ Warp è´¦å·ï¼Ÿ`)) return;

    try {
      setLoading(true);
      let success = 0;
      let failed = 0;

      for (const mcp of mcpServers) {
        try {
          await invoke('upload_mcp_auto', { service: mcp });
          success++;
        } catch {
          failed++;
        }
      }

      setMessage({ 
        type: failed > 0 ? 'error' : 'success', 
        text: `åº”ç”¨å®Œæˆï¼šæˆåŠŸ ${success} ä¸ªï¼Œå¤±è´¥ ${failed} ä¸ª` 
      });
    } finally {
      setLoading(false);
    }
  };

  // å¯¼å…¥ JSON é…ç½®
  const handleImportJson = async () => {
    if (!importJson.trim()) {
      setMessage({ type: 'error', text: 'è¯·è¾“å…¥ JSON é…ç½®' });
      return;
    }

    try {
      setLoading(true);
      const parsed = JSON.parse(importJson);
      let mcpImported = 0;
      let ruleImported = 0;
      let failed = 0;
      const errors: string[] = [];

      // æ£€æµ‹æ ¼å¼ï¼šå®Œæ•´ Warp å¯¼å‡ºæ ¼å¼
      if (parsed.mcp_services || parsed.rules) {
        // å¯¼å…¥ MCP
        if (parsed.mcp_services) {
          for (const [name, config] of Object.entries(parsed.mcp_services)) {
            try {
              const mcpConfig = config as any;
              const transport = mcpConfig.transport_type?.CLIServer;
              
              if (!transport?.command) {
                errors.push(`MCP ${name}: ç¼ºå°‘ command`);
                failed++;
                continue;
              }

              // è½¬æ¢ç¯å¢ƒå˜é‡æ ¼å¼
              const envVars: Record<string, string> = {};
              if (Array.isArray(transport.static_env_vars)) {
                transport.static_env_vars.forEach((envVar: any) => {
                  if (envVar.name) {
                    envVars[envVar.name] = envVar.value || '';
                  }
                });
              }

              const mcp: MCPServer = {
                name: mcpConfig.name || name,
                title: mcpConfig.title || name,
                transport_type: {
                  type: 'stdio',
                  command: transport.command,
                  args: transport.args || [],
                  env: Object.keys(envVars).length > 0 ? envVars : undefined,
                },
                uuid: mcpConfig.uuid || crypto.randomUUID(),
              };

              await invoke('save_mcp_service', { service: mcp });
              mcpImported++;
            } catch (err) {
              const errMsg = err instanceof Error ? err.message : String(err);
              console.error(`å¯¼å…¥ MCP ${name} å¤±è´¥:`, err);
              errors.push(`MCP ${name}: ${errMsg}`);
              failed++;
            }
          }
        }

        // å¯¼å…¥è§„åˆ™
        if (parsed.rules) {
          for (const [name, ruleConfig] of Object.entries(parsed.rules)) {
            try {
              const ruleData = ruleConfig as any;
              
              if (!ruleData.content) {
                errors.push(`è§„åˆ™ ${name}: ç¼ºå°‘ content`);
                failed++;
                continue;
              }

              const rule: Rule = {
                name: ruleData.name || name,
                title: ruleData.title || name,
                memory: {
                  name: ruleData.name || name,
                  content: ruleData.content,
                  is_autogenerated: ruleData.is_autogenerated || false,
                },
              };

              await invoke('save_rule', { rule });
              ruleImported++;
            } catch (err) {
              const errMsg = err instanceof Error ? err.message : String(err);
              console.error(`å¯¼å…¥è§„åˆ™ ${name} å¤±è´¥:`, err);
              errors.push(`è§„åˆ™ ${name}: ${errMsg}`);
              failed++;
            }
          }
        }
      } else {
        // ç®€å•æ ¼å¼ï¼š{name: {command, args, env}}
        for (const [name, config] of Object.entries(parsed)) {
          try {
            const mcpConfig = config as any;
            
            if (!mcpConfig.command) {
              errors.push(`${name}: ç¼ºå°‘ command`);
              failed++;
              continue;
            }

            const envVars: Record<string, string> = {};
            if (mcpConfig.env && typeof mcpConfig.env === 'object') {
              Object.assign(envVars, mcpConfig.env);
            }

            const mcp: MCPServer = {
              name,
              title: name,
              transport_type: {
                type: 'stdio',
                command: mcpConfig.command,
                args: mcpConfig.args || [],
                env: Object.keys(envVars).length > 0 ? envVars : undefined,
              },
              uuid: crypto.randomUUID(),
            };

            await invoke('save_mcp_service', { service: mcp });
            mcpImported++;
          } catch (err) {
            const errMsg = err instanceof Error ? err.message : String(err);
            console.error(`å¯¼å…¥ ${name} å¤±è´¥:`, err);
            errors.push(`${name}: ${errMsg}`);
            failed++;
          }
        }
      }

      if (errors.length > 0) {
        console.error('å¯¼å…¥é”™è¯¯:', errors);
      }

      const total = mcpImported + ruleImported;
      setMessage({ 
        type: failed > 0 ? 'error' : 'success', 
        text: `å¯¼å…¥å®Œæˆï¼š${mcpImported} ä¸ª MCPã€${ruleImported} æ¡è§„åˆ™ï¼Œå¤±è´¥ ${failed} ä¸ª${errors.length > 0 ? ' (è¯¦è§æ§åˆ¶å°)' : ''}` 
      });
      
      if (total > 0) {
        setImportJson('');
        setShowImportForm(false);
        await loadData();
      }
    } catch (error) {
      const errMsg = error instanceof Error ? error.message : String(error);
      setMessage({ type: 'error', text: `JSON è§£æå¤±è´¥: ${errMsg}` });
    } finally {
      setLoading(false);
    }
  };

  // ä¸€é”®åº”ç”¨æ‰€æœ‰ MCP å’Œè§„åˆ™åˆ°äº‘ç«¯
  const applyAllToCloud = async () => {
    const totalCount = mcpServers.length + rules.length;
    if (totalCount === 0) {
      setMessage({ type: 'error', text: 'æ²¡æœ‰é…ç½®å¯ä»¥åº”ç”¨' });
      return;
    }

    if (!confirm(`ç¡®å®šå°†æ‰€æœ‰é…ç½®ï¼ˆ${mcpServers.length} ä¸ª MCP + ${rules.length} æ¡è§„åˆ™ï¼‰åº”ç”¨åˆ°å½“å‰ Warp è´¦å·ï¼Ÿ`)) return;

    try {
      setLoading(true);
      let mcpSuccess = 0;
      let ruleSuccess = 0;
      let failed = 0;

      // åº”ç”¨æ‰€æœ‰ MCP
      for (const mcp of mcpServers) {
        try {
          await invoke('upload_mcp_auto', { service: mcp });
          mcpSuccess++;
        } catch {
          failed++;
        }
      }

      // åº”ç”¨æ‰€æœ‰è§„åˆ™
      for (const rule of rules) {
        try {
          await invoke('upload_rule_auto', { rule });
          ruleSuccess++;
        } catch {
          failed++;
        }
      }

      setMessage({ 
        type: failed > 0 ? 'error' : 'success', 
        text: `åº”ç”¨å®Œæˆï¼š${mcpSuccess} ä¸ª MCPã€${ruleSuccess} æ¡è§„åˆ™ï¼Œå¤±è´¥ ${failed} ä¸ª` 
      });
    } finally {
      setLoading(false);
    }
  };

  // æ‰¹é‡åº”ç”¨æ‰€æœ‰è§„åˆ™åˆ°äº‘ç«¯
  const applyAllRulesToCloud = async () => {
    if (rules.length === 0) {
      setMessage({ type: 'error', text: 'æ²¡æœ‰è§„åˆ™å¯ä»¥åº”ç”¨' });
      return;
    }

    if (!confirm(`ç¡®å®šå°†æ‰€æœ‰ ${rules.length} æ¡è§„åˆ™åº”ç”¨åˆ°å½“å‰ Warp è´¦å·ï¼Ÿ`)) return;

    try {
      setLoading(true);
      let success = 0;
      let failed = 0;

      for (const rule of rules) {
        try {
          await invoke('upload_rule_auto', { rule });
          success++;
        } catch {
          failed++;
        }
      }

      setMessage({ 
        type: failed > 0 ? 'error' : 'success', 
        text: `åº”ç”¨å®Œæˆï¼šæˆåŠŸ ${success} æ¡ï¼Œå¤±è´¥ ${failed} æ¡` 
      });
    } finally {
      setLoading(false);
    }
  };

  // è‡ªåŠ¨æ¸…é™¤æ¶ˆæ¯
  useEffect(() => {
    if (message) {
      const timer = setTimeout(() => setMessage(null), 3000);
      return () => clearTimeout(timer);
    }
  }, [message]);

  return (
    <div className="mcp-manager page-content">
      <h2>MCP å’Œè§„åˆ™ç®¡ç†</h2>

      {message && (
        <div className={`message message-${message.type}`}>
          {message.text}
        </div>
      )}

      {/* æ ‡ç­¾åˆ‡æ¢ */}
      <div className="tabs-container">
        <div className="tabs">
          <button 
            className={`tab ${activeTab === 'mcp' ? 'active' : ''}`}
            onClick={() => setActiveTab('mcp')}
          >
            MCP æœåŠ¡å™¨ ({mcpServers.length})
          </button>
          <button 
            className={`tab ${activeTab === 'rules' ? 'active' : ''}`}
            onClick={() => setActiveTab('rules')}
          >
            è§„åˆ™ç®¡ç† ({rules.length})
          </button>
        </div>
        <button 
          className="apply-all-global-btn" 
          onClick={applyAllToCloud} 
          disabled={loading || (mcpServers.length === 0 && rules.length === 0)}
        >
          â˜ï¸ ä¸€é”®åº”ç”¨æ‰€æœ‰ ({mcpServers.length + rules.length})
        </button>
      </div>

      {/* MCP æœåŠ¡å™¨ç®¡ç† */}
      {activeTab === 'mcp' && (
        <div className="tab-content">
          <div className="header-actions">
            <button className="add-btn" onClick={() => setShowMcpForm(!showMcpForm)} disabled={loading}>
              â• æ·»åŠ  MCP æœåŠ¡å™¨
            </button>
            <button className="import-btn" onClick={() => setShowImportForm(!showImportForm)} disabled={loading}>
              ğŸ“¥ å¯¼å…¥ JSON
            </button>
            <button className="apply-all-btn" onClick={applyAllMcpToCloud} disabled={loading || mcpServers.length === 0}>
              â˜ï¸ å…¨éƒ¨åº”ç”¨åˆ°äº‘ç«¯
            </button>
          </div>

          {showImportForm && (
            <div className="form-card">
              <h3>å¯¼å…¥ MCP é…ç½®</h3>
              <div className="form-group">
                <label>JSON é…ç½® *</label>
                <textarea 
                  value={importJson}
                  onChange={(e) => setImportJson(e.target.value)}
                  placeholder='{"mcp_services": {...}, "rules": {...}}'
                  rows={12}
                  style={{ fontFamily: 'monospace', fontSize: '13px' }}
                />
                <div style={{ fontSize: '12px', color: '#666', marginTop: '8px' }}>
                  æ”¯æŒä¸¤ç§æ ¼å¼ï¼š<br />
                  1. å®Œæ•´å¯¼å‡ºï¼š<code>{'{"mcp_services": {...}, "rules": {...}}'}</code><br />
                  2. ç®€å•æ ¼å¼ï¼š<code>{'{"name": {"command": "...", "args": [...]}}'}</code>
                </div>
              </div>
              <div className="form-actions">
                <button className="btn-primary" onClick={handleImportJson} disabled={loading}>
                  {loading ? 'å¯¼å…¥ä¸­...' : 'å¯¼å…¥'}
                </button>
                <button className="btn-secondary" onClick={() => setShowImportForm(false)}>å–æ¶ˆ</button>
              </div>
            </div>
          )}

          {showMcpForm && (
            <div className="form-card">
              <h3>{editingMcp ? 'ç¼–è¾‘ MCP æœåŠ¡å™¨' : 'æ·»åŠ  MCP æœåŠ¡å™¨'}</h3>
              <div className="form-group">
                <label>æœåŠ¡åç§° *</label>
                <input 
                  type="text"
                  value={newMcp.name}
                  onChange={(e) => setNewMcp({ ...newMcp, name: e.target.value })}
                  placeholder="ä¾‹å¦‚: Filesystem Server"
                />
              </div>
              <div className="form-group">
                <label>ä¼ è¾“ç±»å‹</label>
                <select 
                  value={newMcp.type}
                  onChange={(e) => setNewMcp({ ...newMcp, type: e.target.value })}
                >
                  <option value="stdio">stdio</option>
                  <option value="sse">sse</option>
                </select>
              </div>
              <div className="form-group">
                <label>å‘½ä»¤ *</label>
                <input 
                  type="text"
                  value={newMcp.command}
                  onChange={(e) => setNewMcp({ ...newMcp, command: e.target.value })}
                  placeholder="ä¾‹å¦‚: npx"
                />
              </div>
              <div className="form-group">
                <label>å‚æ•°ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰</label>
                <input 
                  type="text"
                  value={newMcp.args}
                  onChange={(e) => setNewMcp({ ...newMcp, args: e.target.value })}
                  placeholder="ä¾‹å¦‚: -y, @modelcontextprotocol/server-filesystem, /path"
                />
              </div>
              <div className="form-group">
                <label>ç¯å¢ƒå˜é‡ï¼ˆJSON æ ¼å¼ï¼Œå¯é€‰ï¼‰</label>
                <textarea
                  value={newMcp.env}
                  onChange={(e) => setNewMcp({ ...newMcp, env: e.target.value })}
                  placeholder='ä¾‹å¦‚: {"KEY": "value"}'
                  rows={3}
                />
              </div>
              <div className="form-actions">
                <button className="btn-primary" onClick={editingMcp ? saveEditedMcp : handleAddMcp} disabled={loading}>
                  {loading ? (editingMcp ? 'ä¿å­˜ä¸­...' : 'æ·»åŠ ä¸­...') : (editingMcp ? 'ä¿å­˜' : 'æ·»åŠ ')}
                </button>
                <button className="btn-secondary" onClick={editingMcp ? cancelEditMcp : () => setShowMcpForm(false)}>å–æ¶ˆ</button>
              </div>
            </div>
          )}

          <div className="list">
            {mcpServers.length === 0 && !loading && (
              <div className="empty-state">æš‚æ—  MCP æœåŠ¡å™¨é…ç½®</div>
            )}
            {mcpServers.map(mcp => (
              <div key={mcp.name} className="list-item">
                <div className="item-header">
                  <div className="item-title">
                    <span className="status-dot enabled"></span>
                    <strong>{mcp.title}</strong>
                  </div>
                  <div className="item-actions">
                    <button className="edit-btn" onClick={() => startEditMcp(mcp)} disabled={loading}>
                      âœï¸ ç¼–è¾‘
                    </button>
                    <button className="apply-btn" onClick={() => applyMcpToCloud(mcp)} disabled={loading}>
                      â˜ï¸ åº”ç”¨åˆ°äº‘ç«¯
                    </button>
                    <button className="delete-btn" onClick={() => deleteMcp(mcp.name)} disabled={loading}>
                      ğŸ—‘ï¸ åˆ é™¤
                    </button>
                  </div>
                </div>
                <div className="item-details">
                  <div><strong>ç±»å‹:</strong> {mcp.transport_type.type}</div>
                  <div><strong>å‘½ä»¤:</strong> {mcp.transport_type.command}</div>
                  <div><strong>å‚æ•°:</strong> {mcp.transport_type.args.join(', ')}</div>
                  {mcp.cached_at && <div className="cached-time">ç¼“å­˜æ—¶é—´: {new Date(mcp.cached_at).toLocaleString()}</div>}
                </div>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* è§„åˆ™ç®¡ç† */}
      {activeTab === 'rules' && (
        <div className="tab-content">
          <div className="header-actions">
            <button className="add-btn" onClick={() => setShowRuleForm(!showRuleForm)} disabled={loading}>
              â• æ·»åŠ è§„åˆ™
            </button>
            <button className="apply-all-btn" onClick={applyAllRulesToCloud} disabled={loading || rules.length === 0}>
              â˜ï¸ å…¨éƒ¨åº”ç”¨åˆ°äº‘ç«¯
            </button>
          </div>

          {showRuleForm && (
            <div className="form-card">
              <h3>{editingRule ? 'ç¼–è¾‘è§„åˆ™' : 'æ·»åŠ è§„åˆ™'}</h3>
              <div className="form-group">
                <label>è§„åˆ™åç§° *</label>
                <input 
                  type="text"
                  value={newRule.name}
                  onChange={(e) => setNewRule({ ...newRule, name: e.target.value })}
                  placeholder="ä¾‹å¦‚: ä»£ç æ ¼å¼åŒ–è§„åˆ™"
                />
              </div>
              <div className="form-group">
                <label>è§„åˆ™å†…å®¹ *</label>
                <textarea 
                  value={newRule.content}
                  onChange={(e) => setNewRule({ ...newRule, content: e.target.value })}
                  placeholder="è¾“å…¥è§„åˆ™å†…å®¹..."
                  rows={6}
                />
              </div>
              <div className="form-actions">
                <button className="btn-primary" onClick={editingRule ? saveEditedRule : handleAddRule} disabled={loading}>
                  {loading ? (editingRule ? 'ä¿å­˜ä¸­...' : 'æ·»åŠ ä¸­...') : (editingRule ? 'ä¿å­˜' : 'æ·»åŠ ')}
                </button>
                <button className="btn-secondary" onClick={editingRule ? cancelEditRule : () => setShowRuleForm(false)}>å–æ¶ˆ</button>
              </div>
            </div>
          )}

          <div className="list">
            {rules.length === 0 && !loading && (
              <div className="empty-state">æš‚æ— è§„åˆ™é…ç½®</div>
            )}
            {rules.map(rule => {
              const isExpanded = expandedRules.has(rule.name);
              
              return (
                <div key={rule.name} className="list-item">
                  <div className="item-header">
                    <div className="item-title">
                      <span className={`status-dot ${rule.memory.is_autogenerated ? 'disabled' : 'enabled'}`}></span>
                      <strong>{rule.title}</strong>
                      {rule.memory.is_autogenerated && <span className="badge">è‡ªåŠ¨ç”Ÿæˆ</span>}
                    </div>
                    <div className="item-actions">
                      <button className="edit-btn" onClick={() => startEditRule(rule)} disabled={loading}>
                        âœï¸ ç¼–è¾‘
                      </button>
                      <button className="apply-btn" onClick={() => applyRuleToCloud(rule)} disabled={loading}>
                        â˜ï¸ åº”ç”¨åˆ°äº‘ç«¯
                      </button>
                      <button className="delete-btn" onClick={() => deleteRule(rule.name)} disabled={loading}>
                        ğŸ—‘ï¸ åˆ é™¤
                      </button>
                    </div>
                  </div>
                  {isExpanded && (
                    <div className="item-details">
                      <div className="rule-content">
                        {rule.memory.content}
                      </div>
                      {rule.cached_at && <div className="cached-time">ç¼“å­˜æ—¶é—´: {new Date(rule.cached_at).toLocaleString()}</div>}
                    </div>
                  )}
                  <button 
                    className="expand-btn" 
                    onClick={() => toggleRuleExpand(rule.name)}
                  >
                    {isExpanded ? 'â–² æ”¶èµ·' : 'â–¼ å±•å¼€æŸ¥çœ‹å…¨éƒ¨'}
                  </button>
                </div>
              );
            })}
          </div>
        </div>
      )}

      {/* å¹¿å‘Šæ  */}
      <div className="ad-banner">
        <span className="ad-icon">ğŸ</span>
        <span className="ad-text">è´­ä¹° Warp 2500 é¢åº¦è´¦æˆ·</span>
        <span className="ad-price">ğŸ’° <strong>1å…ƒ</strong>/ä¸ª</span>
        <span className="ad-group">
          QQç¾¤: 
          <a 
            href="https://qm.qq.com/q/vi1EFO0mxG" 
            target="_blank" 
            rel="noopener noreferrer"
            className="ad-group-link"
          >
            1014952167
          </a>
        </span>
      </div>
    </div>
  );
}

export default MCPManager;
